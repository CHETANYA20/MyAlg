import java.util.Scanner;

/**
 * Created with IntelliJ IDEA.
 * User: yuantian
 * Date: 2/3/13
 * Time: 11:12 PM
 * To change this template use File | Settings | File Templates.
 * <p/>
 * Dead Pixels (45 points)
 *
 * John's friend Peter purchases a new high resolution monitor with dimension W * H where W is the number
 * of pixels in each row (i.e. width) and H is the number of pixels in each column (i.e. height).
 * <p/>
 * However, there are N dead pixels on the monitor. The i-th dead pixel is located at (x[i], y[i]). (0, 0) is
 * the top-left pixel and (W - 1, H - 1) is the bottom-right pixel. The locations of the dead pixels could be
 * generated by 6 given integers X, Y, a, b, c and d by the following rules. If 2 pixels are at the same location,
 * they are considered the same. It is possible that there are less than N distinct dead pixels.
 * <p/>
 * x[0] = X
 * y[0] = Y
 * x[i] = (x[i - 1] * a + y[i - 1] * b + 1) % W (for 0 < i < N)
 * y[i] = (x[i - 1] * c + y[i - 1] * d + 1) % H (for 0 < i < N)
 * Peter connects his monitor to his computer and opens an image with dimension P (width) * Q (height). How many
 * unique positions can the image be placed so that it can be displayed perfectly (i.e. all pixels of the picture
 * are shown on the monitor)? The image cannot be rotated.
 * <p/>
 * Input
 * The first line contains an integer T, which is the number of test cases. Then T test cases follow. Each test case
 * contains 11 integers W, H, P, Q, N, X, Y, a, b, c, d.
 * <p/>
 * Output
 * For each of the test cases numbered in order from 1 to T, output "Case #", followed by the case number (with 1
 * being the first test case), followed by ": ", followed by an integer which is the number of different possible
 * positions for the poster.
 * <p/>
 * Constraints
 * 1 ≤ T ≤ 20
 * 1 ≤ W, H ≤ 40 000
 * 1 ≤ P ≤ W
 * 1 ≤ Q ≤ H
 * 1 ≤ N ≤ min(1 000 000, W * H)
 * 1 ≤ a, b, c, d ≤ 100
 * 0 ≤ X < W
 * 0 ≤ Y < H
 * <p/>
 * <p/>
 * Example input
 * 5
 * 4 4 2 2 1 0 2 1 2 3 4
 * 4 4 1 1 3 1 1 2 2 2 2
 * 6 10 3 2 2 0 0 5 4 3 2
 * 16 18 5 1 5 10 8 21 27 29 87
 * 14 15 12 4 4 3 5 84 74 53 68
 * <p/>
 * Example output
 * Case #1: 7
 * Case #2: 15
 * Case #3: 32
 * Case #4: 197
 * Case #5: 16
 *
 * 第三题大约是求矩形并集的面积..
 * http://www.cse.iitd.ernet.in/~ssen/cs852/newscribe/soumyadip.pdf
 *
 */
public class DeadPixel {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int t = Integer.parseInt(in.nextLine());
        for (int t1 = 1; t1 <= t; t1++) {
            String[] field = in.nextLine().split(" ");
            // W, H, P, Q, N, X, Y, a, b, c, d.
            int W = Integer.parseInt(field[0]);
            int H = Integer.parseInt(field[1]);
            int P = Integer.parseInt(field[2]);
            int Q = Integer.parseInt(field[3]);
            int N = Integer.parseInt(field[4]);
            int X = Integer.parseInt(field[5]);
            int Y = Integer.parseInt(field[6]);
            int a = Integer.parseInt(field[7]);
            int b = Integer.parseInt(field[8]);
            int c = Integer.parseInt(field[9]);
            int d = Integer.parseInt(field[10]);

            int[][] screen = getScreen(W, H, N, X, Y, a, b, c, d);

            System.out.println("Case #" + t1 + ": " + process(screen, W, H, P, Q));
        }
    }

    static long process(int[][] screen, int W, int H, int P, int Q) {
        long total = 0;
        int[] line = new int[W];

        for(int i = 0; i < H; i++) {
            for(int j = 0; j < W; j++) {
                //Integer[] point = {i,j};
                if(screen[i][j] == -1)
                    line[j] = 0;
                else
                    line[j]++;
            }
            int[] list = new int[W+1];
            int l = 0, r = 0;
            for(int j = 0; j < W; j++) {
                int height = line[j];
                int l1 = l, r1 = r;
                while(l1 < r1) {
                    int mid = (l1+r1)/2;
                    if(line[list[mid]] < height)
                        l1 = mid+1;
                    else
                        r1 = mid;
                }
                list[l1] = j;
                r = l1+1;
                if(j >= P-1) {
                    if(list[l] <= j-P)
                        l++;
                    if(Q <= line[list[l]])
                        total++;
                }
            }
        }
        return total;
    }

    static int[][] getScreen(int W, int H, int N, int X, int Y, int a, int b, int c, int d) {
        //HashSet<Integer[]> screen = new HashSet<Integer[]>();
        int[][] s1 = new int[H][W];
        s1[Y][X]  = -1;
        //Integer[] point = {Y, X};
        //screen.add(point);
        int preX = X, preY = Y;
        for(int i = 1; i < N; i++) {
            int x = (preX * a + preY * b + 1) % W;
            int y = (preX * c + preY * d + 1) % H;
            preX = x;
            preY = y;
            //Integer[] aPoint = {y, x};
            //screen.add(aPoint);
            s1[y][x]  = -1;
        }

        /*
        for(Integer[] row : screen) {
            for(int col : row)
                System.out.printf("%5d", col);
            System.out.println();
        }

        System.out.println();

        for(int[] x : s1) {
            for(int col : x)
                System.out.printf("%5d", col);
            System.out.println();
        }
        System.out.println();

        Integer[] zz = {2,0};
        if(screen.contains(zz))
            System.out.println("YESSSSSS!!!");
            */


        return s1;
    }
}
